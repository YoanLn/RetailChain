-- 04_etl_functions.sql -
-- ETL staging -> dwh avec monitoring & métriques


-- Tables de monitoring et de métriques ETL
CREATE TABLE IF NOT EXISTS dwh.etl_runs (
    run_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    ended_at TIMESTAMPTZ,
    status VARCHAR(20) NOT NULL DEFAULT 'RUNNING', -- RUNNING | SUCCESS | FAILED
    error_message TEXT
);

CREATE TABLE IF NOT EXISTS dwh.etl_events (
    event_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    run_id BIGINT NOT NULL,
    step VARCHAR(100) NOT NULL,
    level VARCHAR(10) NOT NULL, -- INFO | WARN | ERROR
    message TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT fk_etl_events_run FOREIGN KEY (run_id) REFERENCES dwh.etl_runs(run_id)
);

CREATE TABLE IF NOT EXISTS dwh.etl_metrics (
    metric_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    run_id BIGINT NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value NUMERIC(20,2) NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT fk_etl_metrics_run FOREIGN KEY (run_id) REFERENCES dwh.etl_runs(run_id)
);

-- Fonctions permettant de log et d'avoir les métriques
CREATE OR REPLACE FUNCTION dwh.log_event(run_id BIGINT, p_step TEXT, p_level TEXT, p_message TEXT)
RETURNS VOID AS $$
BEGIN
    INSERT INTO dwh.etl_events(run_id, step, level, message)
    VALUES (run_id, p_step, UPPER(p_level), p_message);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION dwh.log_metric(run_id BIGINT, p_name TEXT, p_value NUMERIC)
RETURNS VOID AS $$
BEGIN
    INSERT INTO dwh.etl_metrics(run_id, metric_name, metric_value)
    VALUES (run_id, p_name, p_value);
END;
$$ LANGUAGE plpgsql;


-- Fonction pour faire un Upsert de SCD Type 2 pour la table de dimension customer
CREATE OR REPLACE FUNCTION dwh.upsert_dim_customer_scd2(
    run_id BIGINT,
    p_customer_business_key INTEGER,
    p_first_name VARCHAR,
    p_last_name VARCHAR,
    p_email VARCHAR,
    p_gender VARCHAR,
    p_country VARCHAR,
    p_city VARCHAR,
    p_birth_date DATE
) RETURNS VOID AS $$
DECLARE
    id_existant INTEGER;
    a_change BOOLEAN;
BEGIN
    -- On cherche si il y a une ligne courante pour ce BK
    SELECT customer_key
    INTO id_existant
    FROM dwh.dim_customer
    WHERE customer_business_key = p_customer_business_key
      AND is_current = TRUE;

    IF id_existant IS NULL THEN
        -- Insert initial
        INSERT INTO dwh.dim_customer (
            customer_business_key, first_name, last_name, email, gender,
            country, city, birth_date, valid_to, is_current
        ) VALUES (
            p_customer_business_key, p_first_name, p_last_name, p_email, p_gender,
            p_country, p_city, p_birth_date, NULL, TRUE
        );
        PERFORM dwh.log_event(run_id, 'dim_customer', 'INFO', 'Inserted new customer BK='||p_customer_business_key);
    ELSE
        -- Vérifier si changement sur les colonnes suivies
        SELECT (
            (dc.first_name IS DISTINCT FROM p_first_name) OR
            (dc.last_name  IS DISTINCT FROM p_last_name)  OR
            (dc.email      IS DISTINCT FROM p_email)      OR
            (dc.gender     IS DISTINCT FROM p_gender)     OR
            (dc.country    IS DISTINCT FROM p_country)    OR
            (dc.city       IS DISTINCT FROM p_city)       OR
            (dc.birth_date IS DISTINCT FROM p_birth_date)
        )
        INTO a_change
        FROM dwh.dim_customer dc
        WHERE dc.customer_key = id_existant;

        IF a_change THEN
            -- Fermer l’enregistrement courant
            UPDATE dwh.dim_customer
            SET valid_to = CURRENT_DATE - 1, is_current = FALSE
            WHERE customer_key = id_existant;

            -- Créer une nouvelle version (c'est le SCD Type 2)
            INSERT INTO dwh.dim_customer (
                customer_business_key, first_name, last_name, email, gender,
                country, city, birth_date, valid_from, valid_to, is_current
            ) VALUES (
                p_customer_business_key, p_first_name, p_last_name, p_email, p_gender,
                p_country, p_city, p_birth_date, CURRENT_DATE, NULL, TRUE
            );
            PERFORM dwh.log_event(run_id, 'dim_customer', 'INFO', 'SCD2 change for BK='||p_customer_business_key);
        END IF;
    END IF;
EXCEPTION WHEN unique_violation THEN
    -- Collisions de BK courants : on corrige en forçant la fermeture
    UPDATE dwh.dim_customer
    SET valid_to = CURRENT_DATE - 1, is_current = FALSE
    WHERE customer_business_key = p_customer_business_key
      AND is_current = TRUE;
    INSERT INTO dwh.dim_customer (
        customer_business_key, first_name, last_name, email, gender,
        country, city, birth_date, valid_from, valid_to, is_current
    ) VALUES (
        p_customer_business_key, p_first_name, p_last_name, p_email, p_gender,
        p_country, p_city, p_birth_date, CURRENT_DATE, NULL, TRUE
    );
    PERFORM dwh.log_event(run_id, 'dim_customer', 'WARN', 'Resolved unique violation for BK='||p_customer_business_key);
WHEN others THEN
    PERFORM dwh.log_event(run_id, 'dim_customer', 'ERROR', SQLERRM);
    RAISE;
END;
$$ LANGUAGE plpgsql;

-- Fonction pour faire un Upsert de SCD Type 2 pour la table de dimension produit
CREATE OR REPLACE FUNCTION dwh.upsert_dim_product_scd2(
    run_id BIGINT,
    p_product_business_key INTEGER,
    p_product_name VARCHAR,
    p_brand VARCHAR,
    p_category VARCHAR,
    p_subcategory VARCHAR,
    p_catalog_price DECIMAL
) RETURNS VOID AS $$
DECLARE
    id_existant INTEGER;
    a_change BOOLEAN;
BEGIN
    SELECT product_key
    INTO id_existant
    FROM dwh.dim_product
    WHERE product_business_key = p_product_business_key
      AND is_current = TRUE;

    IF id_existant IS NULL THEN
        INSERT INTO dwh.dim_product (
            product_business_key, product_name, brand, category, subcategory,
            catalog_price, valid_to, is_current
        ) VALUES (
            p_product_business_key, p_product_name, p_brand, p_category, p_subcategory,
            p_catalog_price, NULL, TRUE
        );
        PERFORM dwh.log_event(run_id, 'dim_product', 'INFO', 'Inserted new product BK='||p_product_business_key);
    ELSE
        SELECT (
            (dp.product_name  IS DISTINCT FROM p_product_name)  OR
            (dp.brand         IS DISTINCT FROM p_brand)         OR
            (dp.category      IS DISTINCT FROM p_category)      OR
            (dp.subcategory   IS DISTINCT FROM p_subcategory)   OR
            (dp.catalog_price IS DISTINCT FROM p_catalog_price)
        )
        INTO a_change
        FROM dwh.dim_product dp
        WHERE dp.product_key = id_existant;

        IF a_change THEN
            UPDATE dwh.dim_product
            SET valid_to = CURRENT_DATE - 1, is_current = FALSE
            WHERE product_key = id_existant;

            INSERT INTO dwh.dim_product (
                product_business_key, product_name, brand, category, subcategory,
                catalog_price, valid_from, valid_to, is_current
            ) VALUES (
                p_product_business_key, p_product_name, p_brand, p_category, p_subcategory,
                p_catalog_price, CURRENT_DATE, NULL, TRUE
            );
            PERFORM dwh.log_event(run_id, 'dim_product', 'INFO', 'SCD2 change for BK='||p_product_business_key);
        END IF;
    END IF;
EXCEPTION WHEN unique_violation THEN
    UPDATE dwh.dim_product
    SET valid_to = CURRENT_DATE - 1, is_current = FALSE
    WHERE product_business_key = p_product_business_key
      AND is_current = TRUE;
    INSERT INTO dwh.dim_product (
        product_business_key, product_name, brand, category, subcategory,
        catalog_price, valid_from, valid_to, is_current
    ) VALUES (
        p_product_business_key, p_product_name, p_brand, p_category, p_subcategory,
        p_catalog_price, CURRENT_DATE, NULL, TRUE
    );
    PERFORM dwh.log_event(run_id, 'dim_product', 'WARN', 'Resolved unique violation for BK='||p_product_business_key);
WHEN others THEN
    PERFORM dwh.log_event(run_id, 'dim_product', 'ERROR', SQLERRM);
    RAISE;
END;
$$ LANGUAGE plpgsql;


-- Fonction pour faire un Upsert de SCD Type 1 pour la table de dimension store
CREATE OR REPLACE FUNCTION dwh.upsert_dim_store_type1(
    run_id BIGINT,
    p_store_business_key INTEGER,
    p_store_name VARCHAR,
    p_city VARCHAR,
    p_country VARCHAR,
    p_region VARCHAR,
    p_store_type VARCHAR,
    p_opening_date DATE
) RETURNS VOID AS $$
BEGIN
    INSERT INTO dwh.dim_store (
        store_business_key, store_name, city, country, region, store_type, opening_date
    ) VALUES (
        p_store_business_key, p_store_name, p_city, p_country, p_region, p_store_type, p_opening_date
    )
    ON CONFLICT (store_business_key) DO UPDATE SET
        store_name   = EXCLUDED.store_name,
        city         = EXCLUDED.city,
        country      = EXCLUDED.country,
        region       = EXCLUDED.region,
        store_type   = EXCLUDED.store_type,
        opening_date = EXCLUDED.opening_date;
    PERFORM dwh.log_event(run_id, 'dim_store', 'INFO', 'Upsert store BK='||p_store_business_key);
EXCEPTION WHEN others THEN
    PERFORM dwh.log_event(run_id, 'dim_store', 'ERROR', SQLERRM);
    RAISE;
END;
$$ LANGUAGE plpgsql;

-- Chargement des dimensions depuis staging
CREATE OR REPLACE FUNCTION dwh.load_dimensions_from_staging(run_id BIGINT)
RETURNS VOID AS $$
DECLARE
    v_count_customers BIGINT;
    v_count_products BIGINT;
    v_count_stores BIGINT;
    ligne RECORD;
BEGIN
    -- Customers (c'est un type SCD2)
    -- On compte les lignes à traiter avant la boucle
    SELECT COUNT(*) INTO v_count_customers FROM staging.customers_raw;
    PERFORM dwh.log_metric(run_id, 'dim_customer_rows_processed', v_count_customers);
    
    FOR ligne IN
        SELECT customer_business_key, first_name, last_name, email, gender,
            country, city, birth_date
        FROM staging.customers_raw
    LOOP
        PERFORM dwh.upsert_dim_customer_scd2(
            run_id, 
            ligne.customer_business_key,
            ligne.first_name,
            ligne.last_name,
            ligne.email,
            ligne.gender,
            ligne.country,
            ligne.city,
            ligne.birth_date
        );    
    END LOOP;

    -- Products (c'est un type SCD2)
    SELECT COUNT(*) INTO v_count_products FROM staging.products_raw;
    PERFORM dwh.log_metric(run_id, 'dim_product_rows_processed', v_count_products);

    FOR ligne IN
        SELECT product_business_key, product_name, brand, category, subcategory, catalog_price
        FROM staging.products_raw
    LOOP
        PERFORM dwh.upsert_dim_product_scd2(
            run_id,
            ligne.product_business_key,
            ligne.product_name,
            ligne.brand,
            ligne.category,
            ligne.subcategory,
            ligne.catalog_price
        );    
    END LOOP;

    -- Stores (c'est un type SCD1)
    SELECT COUNT(*) INTO v_count_stores FROM staging.stores_raw;
    PERFORM dwh.log_metric(run_id, 'dim_store_rows_processed', v_count_stores);
    
    FOR ligne IN
        SELECT store_business_key, store_name, city, country, region, store_type, opening_date
        FROM staging.stores_raw
    LOOP
        PERFORM dwh.upsert_dim_store_type1(
            run_id,
            ligne.store_business_key,
            ligne.store_name,
            ligne.city,
            ligne.country,
            ligne.region,
            ligne.store_type,
            ligne.opening_date
        );    
    END LOOP;

    PERFORM dwh.log_event(run_id, 'dimensions', 'INFO', 'Dimensions loaded from staging');
EXCEPTION WHEN others THEN
    PERFORM dwh.log_event(run_id, 'dimensions', 'ERROR', SQLERRM);
    RAISE;
END;
$$ LANGUAGE plpgsql;


-- Chargement de la fact table depuis staging
CREATE OR REPLACE FUNCTION dwh.load_fact_sales_from_staging(run_id BIGINT)
RETURNS VOID AS $$
DECLARE
    v_inserted BIGINT;
BEGIN
    INSERT INTO dwh.fact_sales (
        date_key, customer_key, store_key, product_key,
        transaction_id, quantity, unit_price, total_amount, discount_amount
    )
    SELECT
        dd.date_key,
        dc.customer_key,
        ds.store_key,
        dp.product_key,
        sr.transaction_id,
        sr.quantity,
        sr.unit_price,
        sr.total_amount,
        sr.discount_amount
    FROM staging.sales_raw sr
    
    -- Jointure Date (simple)
    JOIN dwh.dim_date dd
      ON dd.full_date = sr.transaction_date
      
    -- Jointure Store (Type 1 - simple)
    JOIN dwh.dim_store ds
      ON ds.store_business_key = sr.store_business_key
      
    -- Jointure SCD Type 2 pour Customer
    -- On joint sur la plage de date de validité
    JOIN dwh.dim_customer dc
      ON dc.customer_business_key = sr.customer_business_key
     AND sr.transaction_date BETWEEN dc.valid_from AND COALESCE(dc.valid_to, '9999-12-31')

    -- Jointure SCD Type 2 pour Product
    JOIN dwh.dim_product dp
      ON dp.product_business_key = sr.product_business_key
     AND sr.transaction_date BETWEEN dp.valid_from AND COALESCE(dp.valid_to, '9999-12-31')
     
    -- Gestion des doublons
    ON CONFLICT (transaction_id, product_key) DO NOTHING;

    GET DIAGNOSTICS v_inserted = ROW_COUNT;
    PERFORM dwh.log_metric(run_id, 'fact_sales_inserted', COALESCE(v_inserted,0));

    PERFORM dwh.log_metric(run_id, 'fact_sales_count_total', (SELECT COUNT(*) FROM dwh.fact_sales));
    PERFORM dwh.log_event(run_id, 'fact_sales', 'INFO', 'Fact sales loaded from staging');
EXCEPTION WHEN others THEN
    PERFORM dwh.log_event(run_id, 'fact_sales', 'ERROR', SQLERRM);
    RAISE;
END;
$$ LANGUAGE plpgsql;


-- Fonction principale: run_full_etl()
CREATE OR REPLACE FUNCTION dwh.run_full_etl()
RETURNS BIGINT AS $$
DECLARE
    v_run_id BIGINT;
BEGIN
    -- On démarre le run
    INSERT INTO dwh.etl_runs DEFAULT VALUES RETURNING run_id INTO v_run_id;
    PERFORM dwh.log_event(v_run_id, 'etl', 'INFO', 'ETL run started');

    BEGIN
        -- Étape 1: Charger les dimensions
        PERFORM dwh.load_dimensions_from_staging(v_run_id);

        -- Étape 2: Charger la fact table
        PERFORM dwh.load_fact_sales_from_staging(v_run_id);

        -- Fin OK
        UPDATE dwh.etl_runs SET status = 'SUCCESS', ended_at = NOW() WHERE run_id = v_run_id;
        PERFORM dwh.log_event(v_run_id, 'etl', 'INFO', 'ETL run finished successfully');
    EXCEPTION WHEN others THEN
        -- Gestion d’erreurs globale
        UPDATE dwh.etl_runs SET status = 'FAILED', ended_at = NOW(), error_message = SQLERRM WHERE run_id = v_run_id;
        PERFORM dwh.log_event(v_run_id, 'etl', 'ERROR', SQLERRM);
        RAISE;
    END;

    RETURN v_run_id;
END;
$$ LANGUAGE plpgsql;

-- Fonction d’incrément (delta par date)
CREATE OR REPLACE FUNCTION dwh.run_incremental_etl(p_from_date DATE, p_to_date DATE)
RETURNS BIGINT AS $$
DECLARE
    v_run_id BIGINT;
BEGIN
    INSERT INTO dwh.etl_runs DEFAULT VALUES RETURNING run_id INTO v_run_id;
    PERFORM dwh.log_event(v_run_id, 'etl_incremental', 'INFO', 'Incremental ETL started');

    BEGIN
        -- Charger uniquement les dimensions impactées par l’intervalle de dates
        PERFORM dwh.load_dimensions_from_staging(v_run_id);

        -- Charger seulement les ventes dans l’intervalle
        INSERT INTO dwh.fact_sales (
            date_key, customer_key, store_key, product_key,
            transaction_id, quantity, unit_price, total_amount, discount_amount
        )
        SELECT
            dd.date_key,
            dc.customer_key,
            ds.store_key,
            dp.product_key,
            sr.transaction_id,
            sr.quantity,
            sr.unit_price,
            sr.total_amount,
            sr.discount_amount
        FROM staging.sales_raw sr
        JOIN dwh.dim_date dd
          ON dd.full_date = sr.transaction_date
        JOIN dwh.dim_customer dc
          ON dc.customer_business_key = sr.customer_business_key
          AND sr.transaction_date BETWEEN dc.valid_from AND COALESCE(dc.valid_to, '9999-12-31')        
        JOIN dwh.dim_store ds
          ON ds.store_business_key = sr.store_business_key
        JOIN dwh.dim_product dp
          ON dp.product_business_key = sr.product_business_key
          AND sr.transaction_date BETWEEN dp.valid_from AND COALESCE(dp.valid_to, '9999-12-31')        
          WHERE sr.transaction_date BETWEEN p_from_date AND p_to_date
        ON CONFLICT (transaction_id, product_key) DO NOTHING;

        UPDATE dwh.etl_runs SET status = 'SUCCESS', ended_at = NOW() WHERE run_id = v_run_id;
        PERFORM dwh.log_event(v_run_id, 'etl_incremental', 'INFO', 'Incremental ETL finished successfully');
    EXCEPTION WHEN others THEN
        UPDATE dwh.etl_runs SET status = 'FAILED', ended_at = NOW(), error_message = SQLERRM WHERE run_id = v_run_id;
        PERFORM dwh.log_event(v_run_id, 'etl_incremental', 'ERROR', SQLERRM);
        RAISE;
    END;

    RETURN v_run_id;
END;
$$ LANGUAGE plpgsql;
