-- ============================================
-- 04_etl_functions.sql
-- ETL staging -> dwh avec monitoring & métriques
-- ============================================

-- ------------------------------------------
-- Tables de monitoring / métriques ETL
-- ------------------------------------------
CREATE TABLE IF NOT EXISTS dwh.etl_runs (
    run_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    ended_at TIMESTAMPTZ,
    status VARCHAR(20) NOT NULL DEFAULT 'RUNNING', -- RUNNING | SUCCESS | FAILED
    error_message TEXT
);

CREATE TABLE IF NOT EXISTS dwh.etl_events (
    event_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    run_id BIGINT NOT NULL,
    step VARCHAR(100) NOT NULL,
    level VARCHAR(10) NOT NULL, -- INFO | WARN | ERROR
    message TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT fk_etl_events_run FOREIGN KEY (run_id) REFERENCES dwh.etl_runs(run_id)
);

CREATE TABLE IF NOT EXISTS dwh.etl_metrics (
    metric_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    run_id BIGINT NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value NUMERIC(20,2) NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT fk_etl_metrics_run FOREIGN KEY (run_id) REFERENCES dwh.etl_runs(run_id)
);

-- ------------------------------------------
-- Helpers de log et métriques
-- ------------------------------------------
CREATE OR REPLACE FUNCTION dwh.log_event(p_run_id BIGINT, p_step TEXT, p_level TEXT, p_message TEXT)
RETURNS VOID AS $$
BEGIN
    INSERT INTO dwh.etl_events(run_id, step, level, message)
    VALUES (p_run_id, p_step, UPPER(p_level), p_message);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION dwh.log_metric(p_run_id BIGINT, p_name TEXT, p_value NUMERIC)
RETURNS VOID AS $$
BEGIN
    INSERT INTO dwh.etl_metrics(run_id, metric_name, metric_value)
    VALUES (p_run_id, p_name, p_value);
END;
$$ LANGUAGE plpgsql;

-- ------------------------------------------
-- Upsert SCD Type 2: Customer
-- ------------------------------------------
CREATE OR REPLACE FUNCTION dwh.upsert_dim_customer_scd2(
    p_run_id BIGINT,
    p_customer_business_key INTEGER,
    p_first_name VARCHAR,
    p_last_name VARCHAR,
    p_email VARCHAR,
    p_gender VARCHAR,
    p_country VARCHAR,
    p_city VARCHAR,
    p_birth_date DATE
) RETURNS VOID AS $$
DECLARE
    v_existing_id INTEGER;
    v_changed BOOLEAN;
BEGIN
    -- Existe-t-il une ligne courante ?
    SELECT customer_key
    INTO v_existing_id
    FROM dwh.dim_customer
    WHERE customer_business_key = p_customer_business_key
      AND is_current = TRUE;

    IF v_existing_id IS NULL THEN
        -- Insert initial
        INSERT INTO dwh.dim_customer (
            customer_business_key, first_name, last_name, email, gender,
            country, city, birth_date, valid_from, valid_to, is_current
        ) VALUES (
            p_customer_business_key, p_first_name, p_last_name, p_email, p_gender,
            p_country, p_city, p_birth_date, CURRENT_DATE, NULL, TRUE
        );
        PERFORM dwh.log_event(p_run_id, 'dim_customer', 'INFO', 'Inserted new customer BK='||p_customer_business_key);
    ELSE
        -- Vérifier si changement sur les colonnes suivies
        SELECT (
            (dc.first_name IS DISTINCT FROM p_first_name) OR
            (dc.last_name  IS DISTINCT FROM p_last_name)  OR
            (dc.email      IS DISTINCT FROM p_email)      OR
            (dc.gender     IS DISTINCT FROM p_gender)     OR
            (dc.country    IS DISTINCT FROM p_country)    OR
            (dc.city       IS DISTINCT FROM p_city)       OR
            (dc.birth_date IS DISTINCT FROM p_birth_date)
        )
        INTO v_changed
        FROM dwh.dim_customer dc
        WHERE dc.customer_key = v_existing_id;

        IF v_changed THEN
            -- Fermer l’enregistrement courant
            UPDATE dwh.dim_customer
            SET valid_to = CURRENT_DATE - 1, is_current = FALSE
            WHERE customer_key = v_existing_id;

            -- Créer une nouvelle version
            INSERT INTO dwh.dim_customer (
                customer_business_key, first_name, last_name, email, gender,
                country, city, birth_date, valid_from, valid_to, is_current
            ) VALUES (
                p_customer_business_key, p_first_name, p_last_name, p_email, p_gender,
                p_country, p_city, p_birth_date, CURRENT_DATE, NULL, TRUE
            );
            PERFORM dwh.log_event(p_run_id, 'dim_customer', 'INFO', 'SCD2 change for BK='||p_customer_business_key);
        END IF;
    END IF;
EXCEPTION WHEN unique_violation THEN
    -- Collisions de BK courants (rare): corriger en forçant la fermeture
    UPDATE dwh.dim_customer
    SET valid_to = CURRENT_DATE - 1, is_current = FALSE
    WHERE customer_business_key = p_customer_business_key
      AND is_current = TRUE;
    INSERT INTO dwh.dim_customer (
        customer_business_key, first_name, last_name, email, gender,
        country, city, birth_date, valid_from, valid_to, is_current
    ) VALUES (
        p_customer_business_key, p_first_name, p_last_name, p_email, p_gender,
        p_country, p_city, p_birth_date, CURRENT_DATE, NULL, TRUE
    );
    PERFORM dwh.log_event(p_run_id, 'dim_customer', 'WARN', 'Resolved unique violation for BK='||p_customer_business_key);
WHEN others THEN
    PERFORM dwh.log_event(p_run_id, 'dim_customer', 'ERROR', SQLERRM);
    RAISE;
END;
$$ LANGUAGE plpgsql;

-- ------------------------------------------
-- Upsert SCD Type 2: Product
-- ------------------------------------------
CREATE OR REPLACE FUNCTION dwh.upsert_dim_product_scd2(
    p_run_id BIGINT,
    p_product_business_key INTEGER,
    p_product_name VARCHAR,
    p_brand VARCHAR,
    p_category VARCHAR,
    p_subcategory VARCHAR,
    p_catalog_price DECIMAL
) RETURNS VOID AS $$
DECLARE
    v_existing_id INTEGER;
    v_changed BOOLEAN;
BEGIN
    SELECT product_key
    INTO v_existing_id
    FROM dwh.dim_product
    WHERE product_business_key = p_product_business_key
      AND is_current = TRUE;

    IF v_existing_id IS NULL THEN
        INSERT INTO dwh.dim_product (
            product_business_key, product_name, brand, category, subcategory,
            catalog_price, valid_from, valid_to, is_current
        ) VALUES (
            p_product_business_key, p_product_name, p_brand, p_category, p_subcategory,
            p_catalog_price, CURRENT_DATE, NULL, TRUE
        );
        PERFORM dwh.log_event(p_run_id, 'dim_product', 'INFO', 'Inserted new product BK='||p_product_business_key);
    ELSE
        SELECT (
            (dp.product_name  IS DISTINCT FROM p_product_name)  OR
            (dp.brand         IS DISTINCT FROM p_brand)         OR
            (dp.category      IS DISTINCT FROM p_category)      OR
            (dp.subcategory   IS DISTINCT FROM p_subcategory)   OR
            (dp.catalog_price IS DISTINCT FROM p_catalog_price)
        )
        INTO v_changed
        FROM dwh.dim_product dp
        WHERE dp.product_key = v_existing_id;

        IF v_changed THEN
            UPDATE dwh.dim_product
            SET valid_to = CURRENT_DATE - 1, is_current = FALSE
            WHERE product_key = v_existing_id;

            INSERT INTO dwh.dim_product (
                product_business_key, product_name, brand, category, subcategory,
                catalog_price, valid_from, valid_to, is_current
            ) VALUES (
                p_product_business_key, p_product_name, p_brand, p_category, p_subcategory,
                p_catalog_price, CURRENT_DATE, NULL, TRUE
            );
            PERFORM dwh.log_event(p_run_id, 'dim_product', 'INFO', 'SCD2 change for BK='||p_product_business_key);
        END IF;
    END IF;
EXCEPTION WHEN unique_violation THEN
    UPDATE dwh.dim_product
    SET valid_to = CURRENT_DATE - 1, is_current = FALSE
    WHERE product_business_key = p_product_business_key
      AND is_current = TRUE;
    INSERT INTO dwh.dim_product (
        product_business_key, product_name, brand, category, subcategory,
        catalog_price, valid_from, valid_to, is_current
    ) VALUES (
        p_product_business_key, p_product_name, p_brand, p_category, p_subcategory,
        p_catalog_price, CURRENT_DATE, NULL, TRUE
    );
    PERFORM dwh.log_event(p_run_id, 'dim_product', 'WARN', 'Resolved unique violation for BK='||p_product_business_key);
WHEN others THEN
    PERFORM dwh.log_event(p_run_id, 'dim_product', 'ERROR', SQLERRM);
    RAISE;
END;
$$ LANGUAGE plpgsql;

-- ------------------------------------------
-- Upsert Type 1: Store
-- ------------------------------------------
CREATE OR REPLACE FUNCTION dwh.upsert_dim_store_type1(
    p_run_id BIGINT,
    p_store_business_key INTEGER,
    p_store_name VARCHAR,
    p_city VARCHAR,
    p_country VARCHAR,
    p_region VARCHAR,
    p_store_type VARCHAR,
    p_opening_date DATE
) RETURNS VOID AS $$
BEGIN
    INSERT INTO dwh.dim_store (
        store_business_key, store_name, city, country, region, store_type, opening_date
    ) VALUES (
        p_store_business_key, p_store_name, p_city, p_country, p_region, p_store_type, p_opening_date
    )
    ON CONFLICT (store_business_key) DO UPDATE SET
        store_name   = EXCLUDED.store_name,
        city         = EXCLUDED.city,
        country      = EXCLUDED.country,
        region       = EXCLUDED.region,
        store_type   = EXCLUDED.store_type,
        opening_date = EXCLUDED.opening_date;
    PERFORM dwh.log_event(p_run_id, 'dim_store', 'INFO', 'Upsert store BK='||p_store_business_key);
EXCEPTION WHEN others THEN
    PERFORM dwh.log_event(p_run_id, 'dim_store', 'ERROR', SQLERRM);
    RAISE;
END;
$$ LANGUAGE plpgsql;

-- ------------------------------------------
-- Chargement des dimensions depuis staging
-- ------------------------------------------
CREATE OR REPLACE FUNCTION dwh.load_dimensions_from_staging(p_run_id BIGINT)
RETURNS VOID AS $$
DECLARE
    v_count_customers BIGINT;
    v_count_products BIGINT;
    v_count_stores BIGINT;
BEGIN
    -- Customers (SCD2)
    FOR SELECT
            customer_business_key, first_name, last_name, email, gender,
            country, city, birth_date
        FROM staging.customers_raw
    LOOP
        PERFORM dwh.upsert_dim_customer_scd2(
            p_run_id, 
            customers_raw.customer_business_key,
            customers_raw.first_name,
            customers_raw.last_name,
            customers_raw.email,
            customers_raw.gender,
            customers_raw.country,
            customers_raw.city,
            customers_raw.birth_date
        );
    END LOOP;

    GET DIAGNOSTICS v_count_customers = ROW_COUNT;
    PERFORM dwh.log_metric(p_run_id, 'dim_customer_upserts', COALESCE(v_count_customers,0));

    -- Products (SCD2)
    FOR SELECT
            product_business_key, product_name, brand, category, subcategory, catalog_price
        FROM staging.products_raw
    LOOP
        PERFORM dwh.upsert_dim_product_scd2(
            p_run_id,
            products_raw.product_business_key,
            products_raw.product_name,
            products_raw.brand,
            products_raw.category,
            products_raw.subcategory,
            products_raw.catalog_price
        );
    END LOOP;

    GET DIAGNOSTICS v_count_products = ROW_COUNT;
    PERFORM dwh.log_metric(p_run_id, 'dim_product_upserts', COALESCE(v_count_products,0));

    -- Stores (Type 1)
    FOR SELECT
            store_business_key, store_name, city, country, region, store_type, opening_date
        FROM staging.stores_raw
    LOOP
        PERFORM dwh.upsert_dim_store_type1(
            p_run_id,
            stores_raw.store_business_key,
            stores_raw.store_name,
            stores_raw.city,
            stores_raw.country,
            stores_raw.region,
            stores_raw.store_type,
            stores_raw.opening_date
        );
    END LOOP;

    GET DIAGNOSTICS v_count_stores = ROW_COUNT;
    PERFORM dwh.log_metric(p_run_id, 'dim_store_upserts', COALESCE(v_count_stores,0));

    PERFORM dwh.log_event(p_run_id, 'dimensions', 'INFO', 'Dimensions loaded from staging');
EXCEPTION WHEN others THEN
    PERFORM dwh.log_event(p_run_id, 'dimensions', 'ERROR', SQLERRM);
    RAISE;
END;
$$ LANGUAGE plpgsql;

-- ------------------------------------------
-- Chargement de la fact table depuis staging
-- ------------------------------------------
CREATE OR REPLACE FUNCTION dwh.load_fact_sales_from_staging(p_run_id BIGINT)
RETURNS VOID AS $$
DECLARE
    v_inserted BIGINT;
BEGIN
    -- On construit une requête qui mappe les BK staging aux SK DWH et la date_key
    INSERT INTO dwh.fact_sales (
        date_key, customer_key, store_key, product_key,
        transaction_id, quantity, unit_price, total_amount, discount_amount
    )
    SELECT
        dd.date_key,
        dc.customer_key,
        ds.store_key,
        dp.product_key,
        sr.transaction_id,
        sr.quantity,
        sr.unit_price,
        sr.total_amount,
        sr.discount_amount
    FROM staging.sales_raw sr
    JOIN dwh.dim_date dd
      ON dd.full_date = sr.transaction_date
    JOIN dwh.dim_customer dc
      ON dc.customer_business_key = sr.customer_business_key
     AND dc.is_current = TRUE
    JOIN dwh.dim_store ds
      ON ds.store_business_key = sr.store_business_key
    JOIN dwh.dim_product dp
      ON dp.product_business_key = sr.product_business_key
     AND dp.is_current = TRUE
    ON CONFLICT (transaction_id, product_key) DO NOTHING;

    GET DIAGNOSTICS v_inserted = ROW_COUNT;
    PERFORM dwh.log_metric(p_run_id, 'fact_sales_inserted', COALESCE(v_inserted,0));

    -- Qualité: métriques basiques
    PERFORM dwh.log_metric(p_run_id, 'fact_sales_count_total', (SELECT COUNT(*) FROM dwh.fact_sales));
    PERFORM dwh.log_event(p_run_id, 'fact_sales', 'INFO', 'Fact sales loaded from staging');
EXCEPTION WHEN others THEN
    PERFORM dwh.log_event(p_run_id, 'fact_sales', 'ERROR', SQLERRM);
    RAISE;
END;
$$ LANGUAGE plpgsql;

-- ------------------------------------------
-- Fonction principale: run_full_etl()
-- ------------------------------------------
CREATE OR REPLACE FUNCTION dwh.run_full_etl()
RETURNS BIGINT AS $$
DECLARE
    v_run_id BIGINT;
BEGIN
    -- Démarrer le run
    INSERT INTO dwh.etl_runs DEFAULT VALUES RETURNING run_id INTO v_run_id;
    PERFORM dwh.log_event(v_run_id, 'etl', 'INFO', 'ETL run started');

    BEGIN
        -- Étape 1: Charger les dimensions
        PERFORM dwh.load_dimensions_from_staging(v_run_id);

        -- Étape 2: Charger la fact table
        PERFORM dwh.load_fact_sales_from_staging(v_run_id);

        -- Fin OK
        UPDATE dwh.etl_runs SET status = 'SUCCESS', ended_at = NOW() WHERE run_id = v_run_id;
        PERFORM dwh.log_event(v_run_id, 'etl', 'INFO', 'ETL run finished successfully');
    EXCEPTION WHEN others THEN
        -- Gestion d’erreurs globale
        UPDATE dwh.etl_runs SET status = 'FAILED', ended_at = NOW(), error_message = SQLERRM WHERE run_id = v_run_id;
        PERFORM dwh.log_event(v_run_id, 'etl', 'ERROR', SQLERRM);
        RAISE;
    END;

    RETURN v_run_id;
END;
$$ LANGUAGE plpgsql;

-- ------------------------------------------
-- Option: fonction d’incrément (delta par date)
-- ------------------------------------------
CREATE OR REPLACE FUNCTION dwh.run_incremental_etl(p_from_date DATE, p_to_date DATE)
RETURNS BIGINT AS $$
DECLARE
    v_run_id BIGINT;
BEGIN
    INSERT INTO dwh.etl_runs DEFAULT VALUES RETURNING run_id INTO v_run_id;
    PERFORM dwh.log_event(v_run_id, 'etl_incremental', 'INFO', 'Incremental ETL started');

    BEGIN
        -- Charger uniquement les dimensions impactées (exemples simples: toutes, sinon filtrer par BK list)
        PERFORM dwh.load_dimensions_from_staging(v_run_id);

        -- Charger seulement les ventes dans l’intervalle
        INSERT INTO dwh.fact_sales (
            date_key, customer_key, store_key, product_key,
            transaction_id, quantity, unit_price, total_amount, discount_amount
        )
        SELECT
            dd.date_key,
            dc.customer_key,
            ds.store_key,
            dp.product_key,
            sr.transaction_id,
            sr.quantity,
            sr.unit_price,
            sr.total_amount,
            sr.discount_amount
        FROM staging.sales_raw sr
        JOIN dwh.dim_date dd
          ON dd.full_date = sr.transaction_date
        JOIN dwh.dim_customer dc
          ON dc.customer_business_key = sr.customer_business_key
         AND dc.is_current = TRUE
        JOIN dwh.dim_store ds
          ON ds.store_business_key = sr.store_business_key
        JOIN dwh.dim_product dp
          ON dp.product_business_key = sr.product_business_key
         AND dp.is_current = TRUE
        WHERE sr.transaction_date BETWEEN p_from_date AND p_to_date
        ON CONFLICT (transaction_id, product_key) DO NOTHING;

        UPDATE dwh.etl_runs SET status = 'SUCCESS', ended_at = NOW() WHERE run_id = v_run_id;
        PERFORM dwh.log_event(v_run_id, 'etl_incremental', 'INFO', 'Incremental ETL finished successfully');
    EXCEPTION WHEN others THEN
        UPDATE dwh.etl_runs SET status = 'FAILED', ended_at = NOW(), error_message = SQLERRM WHERE run_id = v_run_id;
        PERFORM dwh.log_event(v_run_id, 'etl_incremental', 'ERROR', SQLERRM);
        RAISE;
    END;

    RETURN v_run_id;
END;
$$ LANGUAGE plpgsql;
